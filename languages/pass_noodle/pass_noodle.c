/**
 * @file	pass_noodle.c
 * @brief	Module parser main
 * @author	Thomas Gijsbers (@RaichuBender)
 */

#ifndef _SYNTAX

#include "pass_noodle.h"
#include <stdio.h>
#include <string.h>

#else // _SYNTAX

#include "parse_module.gen.h"

#endif // _SYNTAX

// Final output to be written
char final_out[4096 * 4096];

// Pointer to output text
char *	   pTxt				= final_out;
// Common accross all types
char *	   identifier		= NULL;
char *	   display_name		= NULL;
char *	   user_description = NULL;
// Type specific
char *	   architecture		= NULL;
char *	   language			= NULL;
char *	   endian			= NULL;
char *	   address_size		= NULL;
// Block end markers
char *	   end_platform		= NULL;
char *	   end_architecture = NULL;
char *	   end_language		= NULL;
char *	   end_mode			= NULL;
// Type detected from parsed file
FILE_TYPE  ftype			= INVALID;
char *	   type_hdr;
char *	   type_hdr_upper;

static void parse_level_0(void);
static void save_output(void);

char *level_0;

int	   main_argc;
char **main_argv;

int main(int argc, const char *argv[])
{
	DBG_TRACE(main);
	// printf("\nRaichu's Decomp Spec Parser\nv%d.%d\n", VERSION);

	main_argc = argc;
	main_argv = argv;

	parse_level_0();
	save_output();

	return 0;
}

#define DO_NOT_EDIT_TEXT "/* This file was generated by the spec parser.\n   Do not edit this file! */\n\n"

static void save_output(void)
{
	DBG_TRACE(save_output);
	char file_name[260];
	sprintf(file_name, "src/%s.module.c", identifier);

	FILE *fp = fopen(file_name, "wb");
	fprintf(fp, DO_NOT_EDIT_TEXT "#include \"%s.h\"\n\n%s\n", type_hdr, final_out);

	char def_cmd[1024];
	sprintf(def_cmd,

			"echo	\"extern %3$s %1$s;\"	"
			"	>>	include/%2$s_def.inc.0	"

			"&&"

			"echo	\"%1$s,\"				"
			"	>>	include/%2$s_def.inc.1	",

			identifier, type_hdr, type_hdr_upper);

	system(def_cmd);
}

BOOL bPreproc = FALSE;

static inline void PARSE_PLATFORM_L0(void)
{
	DBG_TRACE(PARSE_PLATFORM_L0);
	ADD_TXT("PLATFORM %1$s =\n{\n\t\"%1$s\",\n", identifier);

	if (display_name != NULL)
		ADD_TXT("\t\"%s\",\n", display_name)
	else
		ADD_TXT("\t\"%s\",\n", identifier)

	if (user_description != NULL)
		ADD_TXT("\t\"%s\",\n", user_description)
	else
		ADD_TXT("\tNO_DESCRIPTION,\n")

	ADD_TXT("\t\"%s\",\n", architecture);
	ADD_TXT("\t%s,\n", endian);
	ADD_TXT("\t%s,\n", address_size);
	ADD_TXT("};");

	if ((identifier == NULL) || (architecture == NULL) || (endian == NULL) || (address_size == NULL) ||
		(end_platform == NULL))
	{
		FATAL("missing elements");
		exit(-1);
	}
}

static inline void PARSE_ARCHITECTURE_L0(void)
{
	DBG_TRACE(PARSE_ARCHITECTURE_L0);
	ADD_TXT("ARCHITECTURE %1$s =\n{\n\t\"%1$s\",\n", identifier);

	if (display_name != NULL)
		ADD_TXT("\t\"%s\",\n", display_name)
	else
		ADD_TXT("\t\"%s\",\n", identifier)

	if (user_description != NULL)
		ADD_TXT("\t\"%s\",\n", user_description)
	else
		ADD_TXT("\tNO_DESCRIPTION,\n")

	ADD_TXT("\t\"%s\",\n", language);
	ADD_TXT("};");

	if ((identifier == NULL) || (language == NULL) || (end_architecture == NULL))
	{
		FATAL("missing elements");
		exit(-1);
	}
}

static inline void PARSE_LANGUAGE_L0(void)
{
	DBG_TRACE(PARSE_LANGUAGE_L0);
	ADD_TXT("LANGUAGE %1$s =\n{\n\t\"%1$s\",\n", identifier);

	if (display_name != NULL)
		ADD_TXT("\t\"%s\",\n", display_name)
	else
		ADD_TXT("\t\"%s\",\n", identifier)

	if (user_description != NULL)
		ADD_TXT("\t\"%s\",\n", user_description)
	else
		ADD_TXT("\tNO_DESCRIPTION,\n")

	ADD_TXT("};");

	if ((identifier == NULL) || (end_language == NULL))
	{
		FATAL("missing elements");
		exit(-1);
	}
}

static inline void PARSE_MODE_L0(void)
{
	DBG_TRACE(PARSE_MODE_L0);
	// TODO
	if ((identifier == NULL) || (address_size == NULL) || (end_mode == NULL))
	{
		FATAL("missing elements");
		exit(-1);
	}
}

static void parse_level_0(void)
{
	DBG_TRACE(parse_level_0);
	yylex();

	switch (ftype)
	{
	case TYPE_PLATFORM:
		PARSE_PLATFORM_L0();
		break;

	case TYPE_ARCHITECTURE:
		PARSE_ARCHITECTURE_L0();
		break;

	case TYPE_LANGUAGE:
		PARSE_LANGUAGE_L0();
		break;

	case TYPE_MODE:
		PARSE_MODE_L0();
		break;

	default:
		FATAL("unrecognized spec file type");
		exit(-1);
	}
}

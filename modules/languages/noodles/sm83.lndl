#**********************************
#
#	 @file      sm83.lmodule
#	 @author    Thomas Gijsbers (@RaichuBender)
#	 @brief     SM83 Assembly Language Module
#	 @version   0.1
#	 @date      2021／09／24
#
#	 @copyright  © Copyright 2021 — Thomas Gijsbers
#	           	   All rights reserved.
#
#		"GAME BOY" and "GAME BOY COLOR” are
#			trade narks or registered trade
#			mark of Nintendo of America Inc.
#			and／or Nintendo Co., Ltd.
#		Usage under FAIR USE.
#		All rights regarding usage of the
#			aforementioned trade marks belong
#			to their respective owners.
#
#**********************************


LANGUAGE(sm83_asm)
#: Game Boy SM83 (Z80) assembly language

	DisplayName: Game Boy SM83 (Z80) asm

	REGISTER_STORAGE(0x00)
	#: Regular
		Size:	12 BYTES

		# Registers:
		# A F
		REGISTER(AF)
		{
			Mapping:	0x00
			Size:		16 BITS
			Purpose: 	GENERAL
		},
		# Accumulator
		REGISTER(A)
		{
			Mapping:	0x00
			Size:		8 BITS 
			Purpose:	GENERAL
		},
		# Note: F is the flags register defined below

		# B C
		REGISTER(BC)
		{
			Mapping:	0x10
			Size:		16 BITS
			Purpose: 	GENERAL
		},
		REGISTER(B)
		{
			Mapping:	0x10
			Size:		8 BITS 
			Purpose:	GENERAL
		},
		REGISTER(C)
		{
			Mapping:	0x18
			Size:		8 BITS 
			Purpose:	GENERAL
		},

		# D E
		REGISTER(DE)
		{
			Mapping:	0x20
			Size:		16 BITS
			Purpose: 	GENERAL
		},
		REGISTER(D)
		{
			Mapping:	0x20
			Size:		8 BITS 
			Purpose:	GENERAL
		},
		REGISTER(E)
		{
			Mapping:	0x28
			Size:		8 BITS 
			Purpose:	GENERAL
		},

		# H L
		REGISTER(HL)
		{
			Mapping:	0x30
			Size:		16 BITS
			Purpose: 	GENERAL
		},
		REGISTER(H)
		{
			Mapping:	0x30
			Size:		8 BITS 
			Purpose:	GENERAL
		},
		REGISTER(L)
		{
			Mapping:	0x38
			Size:		8 BITS 
			Purpose:	GENERAL
		},


		# Program Counter
		REGISTER(PC)
		{
			Mapping:	0x40
			Size:		16 BITS
			Purpose: 	PROGRAM_COUNTER
		},

		# Stack Pointer
		REGISTER(SP)
		{
			Mapping:	0x50
			Size:		16 BITS
			Purpose: 	STACK_POINTER
		},

		# Flags (paired with A)
		REGISTER(F)
		{
			Mapping:	0x08
			Size:		8 BITS
			Purpose:	FLAGS
		},

		# Flags:
		# Zero
		FLAG(ZF)
		{
			Mapping: 	0x0f
		},

		# Negative (last operation was a subtraction
		FLAG(NF)
		{
			Mapping: 	0x0e
		},

		# Half-Carry (nybble)
		FLAG(HF)
		{
			Mapping: 	0x0d
		},

		# Carry (byte)
		FLAG(CF)
		{
			Mapping: 	0x0c
		}

	END_REGISTER_STORAGE

	INSTRUCTION_SET(REGULAR)
	#: All non-CB instructions

	# Misc
		"NOP":		NOTHING	0x00	1 4
		{
			NO_OP;
		}

		"STOP 0":	SPECIAL	0x10	2 4
		{
			NO_OP;	// TODO
		}

		"HALT":		SPECIAL	0x76	1 4
		{
			NO_OP;	// TODO

		}

	# 8-bit Loads:
MACRO:LOAD( _REG_, _OP_B_ )
=BEGIN
		"LD _REG_, %s": MOV_STOR	GROUP( _OP_B_, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				LOAD REG	_REG_, PARAM[0];
			}
		}
=END

		^%LOAD( B, 0x40 )
		^%LOAD( C, 0x48 )
		^%LOAD( D, 0x50 )
		^%LOAD( E, 0x58 )
		^%LOAD( H, 0x60 )
		^%LOAD( L, 0x68 )

		"LD (HL), %s": MOV_STOR	GROUP( 0x70, 6, 1 )
		{
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)    }
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"   }
			INSTR_COUNT:	1
			CYCLES:			8

			{
				LOAD, REG_ADR(HL) PARAM[0];
			}
		}

		"LD (HL), A": MOV_STOR	0x77	1 8
		{
			LOAD, REG_ADR(HL), REG(A);
		}

		^%LOAD( A, 0x78 )

		"LD %s, 0x%02x", IMM8: MOV_STOR	GROUP( 0x06, 8, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	2
			CYCLES:	{	 4      4      4      4      4      4      12     4    }

			{
				LOAD PARAM[0], CONST(IMM8);
			}
		}

	# 16-bit Loads:
		"LD %s, A", IMM8: MOV_STOR	GROUP( 0x06, 16, 2 )
		{
			REPR:	{	"(BC)"    "(DE)"    "(HL+)"    "(HL-)"   }
			PARAM:	{	REG_ADR(BC)     REG_ADR(DE)     REG_ADR(HL)   REG_ADR(HL)  }
			INSTR_COUNT:	1
			CYCLES:			8

			{
				LOAD	PARAM[0], REG(A);
			}
		}

		"LD (HL+), A":	MOV_STOR	0x26	1 8
		{
			LOAD			REG_ADR(HL), REG(A);
			ARITHMETIC ADD	REG(HL), CONST(1);
		}

		"LD (HL-), A":	MOV_STOR	0x36	1 8
		{
			LOAD			REG_ADR(HL), REG(A);
			ARITHMETIC SUB	REG(HL), CONST(1);
		}

	# 8-bit Arithmetic:
		"INC %s": ARITHMETIC	GROUP( 0x04, 8, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      12     4    }

			{
				ARITHMETIC ADD	PARAM[0], CONST(1);

				LOAD FLAG(ZF), CONDITION(PARAM[0] == 0);
				LOAD FLAG(NF), CONST(false);
				LOAD FLAG(HF), CONDITION(PARAM[0].nl > 0xf);
			}
		}

		"DEC %s": ARITHMETIC	GROUP( 0x05, 8, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      12     4    }

			{
				ARITHMETIC SUB	PARAM[0], CONST(1);

				LOAD FLAG(ZF), CONDITION(PARAM[0] == 0);
				SETFLAG ZF, PARAM[0] == 0;
				SETFLAG NF, true;
				SETFLAG HF, PARAM[0].nl > 0xf;
			}
		}


		"ADD A, %s": ARITHMETIC	GROUP( 0x80, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				ARITHMETIC ADD	REG(A), PARAM[0];

				SETFLAG ZF, A == 0;
				SETFLAG NF, false;
				SETFLAG HF, A.nl > 0xf;
				SETFLAG CF, A > 0xff;
			}
		}

		"ADD A, 0x%02x", IMM8: ARITHMETIC	0xc6	2 8
		{
			ARITHMETIC ADD	REG(A), CONST(IMM8);

			SETFLAG ZF, A == 0;
			SETFLAG NF, false;
			SETFLAG HF, A.nl > 0xf;
			SETFLAG CF, A > 0xff;
		}


		"ADC A, %s": ARITHMETIC	GROUP( 0x88, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				ARITHMETIC ADD	REG(A), FLAG(CF);
				ARITHMETIC ADD	REG(A), PARAM[0];

				SETFLAG ZF, A == 0;
				SETFLAG NF, false;
				SETFLAG HF, A.nl > 0xf;
				SETFLAG CF, A > 0xff;
			}
		}

		"ADC A, 0x%02x", IMM8: ARITHMETIC	0xce	2 8
		{
			ARITHMETIC ADD	REG(A), FLAG(CF);
			ARITHMETIC ADD	REG(A), CONST(IMM8);

			SETFLAG ZF, A == 0;
			SETFLAG NF, false;
			SETFLAG HF, A.nl > 0xf;
			SETFLAG CF, A > 0xff;
		}


		"SUB %s": ARITHMETIC	GROUP( 0x90, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				ARITHMETIC SUB	REG(A), PARAM;

				SETFLAG ZF, A == 0;
				SETFLAG NF, true;
				SETFLAG HF, A.nl > 0xf;
				SETFLAG CF, A > 0xff;
			}
		}

		"SUB A, 0x%02x", IMM8: ARITHMETIC	0xd6	2 8
		{
			ARITHMETIC SUB	REG(A), CONST(IMM8);

			SETFLAG ZF, A == 0;
			SETFLAG NF, true;
			SETFLAG HF, A.nl > 0xf;
			SETFLAG CF, A > 0xff;
		}


		"SBC A, %s": ARITHMETIC	GROUP( 0x98, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				REG_SUB	A, PARAM[0] + CF;

				SETFLAG ZF, A == 0;
				SETFLAG NF, true;
				SETFLAG HF, A.nl > 0xf;
				SETFLAG CF, A > 0xff;
			}
		}

		"SBC A, 0x%02x", IMM8: ARITHMETIC	0xde	2 8
		{
			REG_SUB	A, IMM8 + CF;

			SETFLAG ZF, A == 0;
			SETFLAG NF, true;
			SETFLAG HF, A.nl > 0xf;
			SETFLAG CF, A > 0xff;
		}


		"AND %s": ARITHMETIC	GROUP( 0xa0, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				ARITHMETIC ADD	REG(A), PARAM[0];
			}
		}

		"AND 0x%02x", IMM8: ARITHMETIC	0xe6	2 8
		{
			ARITHMETIC ADD	REG(A), PARAM[0];
		}


		"XOR %s": ARITHMETIC	GROUP( 0xa8, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				ARITHMETIC ADD	REG(A), PARAM[0];
			}
		}

		"XOR 0x%02x", IMM8: ARITHMETIC	0xee	2 8
		{
			ARITHMETIC ADD	REG(A), PARAM[0];
		}


		"OR %s": ARITHMETIC	GROUP( 0xb0, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				ARITHMETIC ADD	REG(A), PARAM[0];
			}
		}

		"OR 0x%02x", IMM8: ARITHMETIC	0xf6	2 8
		{
			ARITHMETIC ADD	REG(A), PARAM[0];
		}


		"CP A, %s": ARITHMETIC	GROUP( 0xb8, 1, 8 )
		{
			REPR:	{	"B"    "C"    "D"    "E"    "H"    "L"    "(HL)" "A"   }
			PARAM:	{	 REG(B)      REG(C)      REG(D)      REG(E)      REG(H)      REG(L)     REG_ADR(HL)   REG(A)    }
			INSTR_COUNT:	1
			CYCLES:	{	 4      4      4      4      4      4      8      4    }

			{
				local a = A;
				REG_SUB	A, PARAM[0];

				SETFLAG ZF, A == 0;
				SETFLAG NF, true;
				SETFLAG HF, A.nl > 0xf;
				SETFLAG CF, A > 0xff;

				A = a;
			}
		}

		"CP 0x%02x", IMM8: ARITHMETIC	0xfe	2 8
		{
			local a = A;
			REG_SUB	A, IMM8;

			SETFLAG ZF, A == 0;
			SETFLAG NF, true;
			SETFLAG HF, A.nl > 0xf;
			SETFLAG CF, A > 0xff;

			A = a;
		}

	##	Branching
	# Unconditional jumps
		"JP 0x%04x", IMM16: JUMP	0xc3	3 16
		{
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"JR 0x%04x", IMM8_R: JUMP	0x18	2 12
		{
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

	# Conditional jumps
		"JP NZ,%04x", IMM16: JUMP	0xc2	3 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"JP Z,%04x", IMM16: JUMP	0xca	3 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"JP NC,%04x", IMM16: JUMP	0xd2	3 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"JP C,%04x", IMM16: JUMP	0xda	3 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}


		"CALL 0x%04x", IMM16: CALL	0xcd	3 24
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}


		"CALL NZ,%04x", IMM16: CALL	0xc4	3 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"CALL Z,%04x", IMM16: CALL	0xcc	3 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"CALL NC,%04x", IMM16: CALL	0xd4	3 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"CALL C,%04x", IMM16: CALL	0xdc	3 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}



		"RET": RETURN	0xc9	1 16
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"RETI": RETURN	0xd9	1 16
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}


		"RET NZ": RETURN	0xc0	1 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"RET Z": RETURN	0xc8	1 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"RET NC": RETURN	0xd0	1 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

		"RET C": RETURN	0xd8	1 12
		{	#				 TODO conditional ^^ 12/16
			BRANCH UNCONDITIONAL	REG(PC)	IMM16;
		}

	END_INSTRUCTION_SET
	# ...

	INSTRUCTION_SET(CB)
	#: ...
	END_INSTRUCTION_SET

END_LANGUAGE

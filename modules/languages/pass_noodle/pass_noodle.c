/**********************************
*
*	 @file      pass_noodle.c
*	 @author    Thomas Gijsbers (@RaichuBender)
*	 @brief     Module parser main
*	 @version   0.1
*	 @date      2021／09／24
*
*	 @copyright  © Copyright 2021 — Thomas Gijsbers
*	           	   All rights reserved.
*
**********************************/

#ifndef _SYNTAX

#include "pass_noodle.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#else // _SYNTAX

#include "pass_noodle.gen.h"

#endif // _SYNTAX


typedef enum
{
	LEX_INVALID = 0,
	LEX_L0,
	LEX_LANGUAGE,
} LEX_TYPE;

// TODO
LEX_TYPE lt;
#define LEX(_type_)  \
	{                \
		lt = _type_; \
		yylex();     \
	}

/*********************************
*
*	@brief
*
*	Global variable —
*	used for providing necessary
*	informatiom during parsing of
*	context sensitive tokens
*
*	Currently in the process
*	of implementing a fully
*	functional abstract syntax
*	tree with psuedo-C
*	decompilation.
*
**********************************/

/*********************************
*	Final output to be written
**********************************/
char final_out[4096 * 4096];

/*********************************
*	Pointer to output text buffer
**********************************/
char *pTxt = final_out;

/*********************************
*	Common accross all types
**********************************/
char *	  identifier	   = NULL;
char *	  display_name	   = NULL;
char *	  user_description = NULL;

/*********************************
*	Type specific
**********************************/
char *	  architecture	   = NULL;
char *	  language		   = NULL;
char *	  endian		   = NULL;
char *	  address_size	   = NULL;

/*********************************
*	Block end markers
**********************************/
char *	  end_platform	   = NULL;
char *	  end_architecture = NULL;
char *	  end_language	   = NULL;
char *	  end_mode		   = NULL;

/*********************************
*	Type detected from parsed file
**********************************/
FILE_TYPE ftype			   = INVALID;
char *	  type_hdr;
char *	  type_hdr_upper;

static void parse_level_0(void);
static void parse_level_1(void);
static void save_output(void);

char * level_0;

int	   main_argc;
char **main_argv;


/*********************************
*
*    @brief	Main Entry
*
*    @param[in]	argc 
*    @param[in]	argv 
*
*    @return	int 
*
*********************************/
int main(int argc, const char *argv[])
{
	DBG_TRACE(main);
	// printf("\nRaichu's Decomp Spec Parser\nv%d.%d\n", VERSION);

	main_argc = argc;
	main_argv = (char **)argv;

	parse_level_0();
	save_output();

	return 0;
}


/**********************************
*
*	 @brief     
*
**********************************/
static void save_output(void)
{
	DBG_TRACE(save_output);

	char file_name[260];
	sprintf(file_name, "src/%s.ndl.c", identifier);

#define DO_NOT_EDIT_TEXT                                \
	"/* This file was generated by the spec parser.\n " \
	"  Do not edit this file! */\n\n"

	FILE *fp = fopen(file_name, "wb");
	fprintf(fp, DO_NOT_EDIT_TEXT
			"#include \"%s.h\"\n\n",
			type_hdr);
	fprintf(fp, "%s\n\n%s\n\n",
			"#define BYTES *8\n#define BITS *1\n",
			final_out);

	char def_cmd[1024];
	sprintf(def_cmd,						   //\n
			"echo	\"extern %3$s %1$s;\""	   //\n
			"	>>	include/%2$s_def.0.gen.h"  //\n
			"&&"							   //\n
			"echo	\"%1$s,\""				   //\n
			"	>>	include/%2$s_def.1.gen.h", //\n
			identifier, type_hdr, type_hdr_upper);

	system(def_cmd);
}


/**********************************
*
*	 @brief     
*
**********************************/
static inline void PARSE_PLATFORM_L0(void)
{
	DBG_TRACE(PARSE_PLATFORM_L0);

	if ((identifier == NULL) || (architecture == NULL) || (endian == NULL) || (address_size == NULL) ||
		(end_platform == NULL))
		FATAL("missing elements", "-", "-", "-");

	ADD_TXT("PLATFORM %1$s =\n{\n\t\"%1$s\",\n", identifier);

	if (display_name != NULL)
		ADD_TXT("\t\"%s\",\n", display_name)
	else
		ADD_TXT("\t\"%s\",\n", identifier)

	if (user_description != NULL)
		ADD_TXT("\t\"%s\",\n", user_description)
	else
		ADD_TXT("\tNO_DESCRIPTION,\n")

	ADD_TXT("\t\"%s\",\n", architecture);
	ADD_TXT("\t%s,\n", endian);
	ADD_TXT("\t%s,\n", address_size);
	ADD_TXT("};");
}


/**********************************
*
*	 @brief     
*
**********************************/
static inline void PARSE_ARCHITECTURE_L0(void)
{
	DBG_TRACE(PARSE_ARCHITECTURE_L0);

	if ((identifier == NULL) || (language == NULL) || (end_architecture == NULL))
		FATAL("missing elements", "-", "-", "-");

	ADD_TXT("ARCHITECTURE %1$s =\n{\n\t\"%1$s\",\n", identifier);

	if (display_name != NULL)
		ADD_TXT("\t\"%s\",\n", display_name)
	else
		ADD_TXT("\t\"%s\",\n", identifier)

	if (user_description != NULL)
		ADD_TXT("\t\"%s\",\n", user_description)
	else
		ADD_TXT("\tNO_DESCRIPTION,\n")

	ADD_TXT("\t\"%s\",\n", language);
	ADD_TXT("};");
}


/**********************************
*
*	 @brief     
*
**********************************/
static inline void PARSE_LANGUAGE_L0(void)
{
	DBG_TRACE(PARSE_LANGUAGE_L0);

	if ((identifier == NULL) || (end_language == NULL))
		FATAL("missing elements", "-", "-", "-");

	ADD_TXT("LANGUAGE %1$s =\n{\n\t\"%1$s\",\n", identifier);

	if (display_name != NULL)
		ADD_TXT("\t\"%s\",\n", display_name)
	else
		ADD_TXT("\t\"%s\",\n", identifier)

	if (user_description != NULL)
		ADD_TXT("\t\"%s\",\n", user_description)
	else
		ADD_TXT("\tNO_DESCRIPTION,\n")

	ADD_TXT("};\t// %s", identifier);
}


/**********************************
*
*	 @brief     
*
**********************************/
static inline void PARSE_MODE_L0(void)
{
	DBG_TRACE(PARSE_MODE_L0);
	// TODO
	if ((identifier == NULL) || (end_mode == NULL))
		FATAL("missing elements", "-", "-", "-");
}


/**********************************
*
*	 @brief     
*
**********************************/
static void parse_level_0(void)
{
	DBG_TRACE(parse_level_0);
	LEX(LEX_L0);

	switch (ftype)
	{
	case TYPE_PLATFORM:
		PARSE_PLATFORM_L0();
		break;

	case TYPE_ARCHITECTURE:
		PARSE_ARCHITECTURE_L0();
		break;

	case TYPE_LANGUAGE:
		PARSE_LANGUAGE_L0();
		break;

	case TYPE_MODE:
		PARSE_MODE_L0();
		break;

	default:
		FATAL("unrecognized spec file type", "-", "-", "-");
	}
}


/**********************************
*
*	 @brief     
*
**********************************/
void DECODE_INSTR(void) {}


/**********************************
*
*	 @brief     
*
*    @param yytext 
*
**********************************/
void REGISTOR(char *yytext)
{
	DBG_TRACE(REGISTOR);

	char *space = strchr(yytext, L'(') + 1;
	char *end	= strchr(space, L')');
	if (end == NULL)
		return; // TODO bail out and show FATAL ERR

	*(end) = 0;

	free(scope_name[++token_scope]);

	scope_name[token_scope] = malloc(32);
	sprintf(scope_name[token_scope], "register_store_%s", space);

	ADD_TXT("REGISTER_STORAGE %s =\n{\n", scope_name[token_scope]);

	tmd[token_scope] = REG_SPACE;
}


/**********************************
*
*	 @brief     
*
*    @param yytext 
*
**********************************/
void INSTRSET(char *yytext)
{
	DBG_TRACE(INSTRSET);
	char *name			  = strchr(yytext, L'(') + 1;
	*(strchr(name, L')')) = 0;

	free(scope_name[++token_scope]);
	tmd[token_scope] = INSTR_SET;

	scope_name[token_scope] = malloc(32);
	sprintf(scope_name[token_scope], "%s", name);

	ADD_TXT("INSTRUCTION_SET %s =\n{\n", name);

	INDENT(token_scope);
	ADD_TXT("/*Name:    */ \"%s\",\n", name);

	INDENT(token_scope++);
	ADD_TXT("{\n");

	tmd[token_scope] = INSTR_SET;
}


/**********************************
*
*	 @brief	Seek past whitespace
*
*    @param[inout] pDST variable reference (?)
*						to seek from and update
*						it's address
*
*   	 @note	Does NOT seek for
*				newlines or comments
*
**********************************/
#define SKIP_WHITESPACE(pDST)                         \
	{                                                 \
		ASSERT(pDST != NULL);                         \
		while (((*pDST) == ' ') || ((*pDST) == '\t')) \
			++pDST;                                   \
	}

/**********************************
*
*	 @brief	Seek backwards, before whitespace.
*
*    @param[inout] pDST variable reference (?)
*						to seek from and update
*						it's address
*
*    	@note	Does NOT seek for
*				newlines or comments
*
**********************************/
#define SKIP_WHITESPACE_BCKWDS(pDST)                  \
	{                                                 \
		ASSERT(pDST != NULL);                         \
		while (((*pDST) == ' ') || ((*pDST) == '\t')) \
			--pDST;                                   \
	}

/**********************************
*
*	 @brief	Seek FOR whitespace
*
*    @param[inout] pDST variable reference (?)
*						to seek from and update
*						it's address
*
*    	@note	Does NOT seek for
*				newlines or comments
*
**********************************/
#define SEEK_WHITESPACE(pDST, pSEEK)       \
	{                                      \
		pDST	  = strchr(pSEEK, L' ');   \
		char *tmp = strchr(pSEEK, L'\t');  \
		if ((tmp != NULL) && (tmp < pDST)) \
			pDST = tmp;                    \
		ASSERT(pDST != NULL);              \
	}

/**********************************
*
*	 @brief	Seek for newline
*			'\n' character
*
*    @param[inout] pDST variable reference (?)
*						to seek from and update
*						it's address
*
*   	 @note	Does NOT seek for
*				any other type of
*				white space
*
**********************************/
#define SEEK_NEWLINE(pDST, pSEEK)    \
	{                                \
		pDST = strchr(pSEEK, L'\n'); \
		ASSERT(pDST != NULL);        \
	}

#define SEEK_NULL_TERM(pDST, pSEEK)  \
	{                                \
		pDST = strchr(pSEEK, L'\0'); \
		ASSERT(pDST != NULL);        \
	}


/**********************************
*
*	 @brief     Query param type
*				by string ref
*
*    @param[in] str string
*				representation of
*				parameter or symbol
*				(register) type to
*				search for matching
*				param
*
*    @return	PARAM_KIND 
*
*  	 		@note	This might not
* 					be feasible to do
* 					during runtime
*
**********************************/
PARAM_KIND get_param_type(char *str)
{
	ASSERT(str != NULL);

	unsigned char cmp = 0;
	cmp	=  ((0 == strcmp(str,  "REG")) || (0 == strcmp(str,  "reg")))		||
		  (((0 == strcmp(str, "IMM8")) || (0 == strcmp(str, "imm8"))) << 1) ||
		  (((0 == strcmp(str, "IMM8")) || (0 == strcmp(str, "imm8"))) << 2) ||
		  (((0 == strcmp(str, "IMM8")) || (0 == strcmp(str, "imm8"))) << 3) ||
		  (((0 == strcmp(str, "IMM8")) || (0 == strcmp(str, "imm8"))) << 4) ||
		  (((0 == strcmp(str, "IMM8")) || (0 == strcmp(str, "imm8"))) << 5) ||
		  (((0 == strcmp(str, "IMM8")) || (0 == strcmp(str, "imm8"))) << 6) ||
		  (((0 == strcmp(str, "IMM8")) || (0 == strcmp(str, "imm8"))) << 7);

	switch (cmp)
	{
	case (0):	return PARAM_NONE;
	case (1):	return PARAM_REG;
	case (2):	return PARAM_IMM;
	case (3):	return PARAM_REG_ADR;
	case (4):	return PARAM_IMM_ADR;
	case (5):	return PARAM_REL_ADR;
	case (6):	return PARAM_IMM_ADR_OFS;
	case (7):	return PARAM_REG_ADR_OFS;
	}
}


/*********************************
*
*	 @brief		Parse instruction specification into
*				C structure format for easy access
*				during runtime
*
*    @param[in]	raw_str 
*    @param[in]	type 
*
**********************************/
void PROC_INSTR(char *raw_str, INSTR_TYPE type)
{
	fprintf(stderr, "%s\n", raw_str);

	char *start = strchr(raw_str, L'\"') + 1;
	ASSERT(start != NULL);

	char *end	= strchr(start, L'\"');
	ASSERT(end != NULL);

	(*end)	   = 0;
	char *next = end + 1;

/****************************************************#
#	Instruction mnemonic parsable string			 #
#****************************************************/
	REPR = malloc(strlen(start) + 1);
	strcpy(REPR, start);

	PARAM		= NULL;
	param_count = 0;

	switch (type)
	{
	case SINGLE_REGULAR:
	default:
		goto SINGLE_skip_param;

	// case SINGLE_PARAM:
	// 	goto SINGLE_param;

	// case GROUPING_REGULAR:
	// 	goto GROUP_skip_param;

	// case GROUPING_PARAM:
	// 	goto GROUP_param;

	// default:
	// 	ASSERT(NULL != strchr(raw_str, L'\"'));
	// 	break;
	}
	// return;

/****************************************************#
#	Instruction parameters in variadic array		 #
#****************************************************/
	char *prm_start;
	char *prm_end;

/** Linked list to account for complex
  * machine instructions	*/
typedef struct _local_param_list
{
	PARAMETER prm;
	void	 *pNext;
} local_param_list;


SINGLE_param:


	prm_start = strchr(next, L',');
	prm_end	  = strchr(next, L':');

	local_param_list *pPrm_list = malloc(sizeof(local_param_list));
	local_param_list *pl		= pPrm_list;

	ASSERT((prm_start != NULL) && (prm_end != NULL));

	next	   = prm_end + 1;
	SKIP_WHITESPACE_BCKWDS(prm_end);
	(*prm_end) = 0;

	for ( ; (prm_start != NULL) && (prm_start++ < prm_end)
		  ; pl->pNext = malloc(sizeof(local_param_list))
		  , pl = pl->pNext )
	{
		SKIP_WHITESPACE(prm_start);

		PARAM_KIND get_param_type(char *str);

		pl->prm.param_idx		= 0;
		pl->prm.type			= get_param_type(prm_start);
		pl->prm.reg_mem_mapping = 0;

		prm_start = strchr(prm_start, L',');
	}

/****************************************************#
#	Instruction's unique OP code					 #
#****************************************************/
	char *op_start;
	char *op_end;


SINGLE_skip_param:


	op_start = strchr(next, L':') + 1;

	SKIP_WHITESPACE(op_start);
	SEEK_WHITESPACE(op_end, op_start);

	(*op_end) = 0;
	next	  = op_end + 1;

	opcode	  = strtoull(op_start, NULL, 16);

/****************************************************#
#	Bytes count of instruction (opcode + operands)	 #
#****************************************************/
	char *cnt_start = next;
	char *cnt_end;

	SKIP_WHITESPACE(cnt_start);
	SEEK_WHITESPACE(cnt_end, cnt_start);

	(*cnt_end) = 0;
	next	   = cnt_end + 1;

	instr_count = strtoul(cnt_start, NULL, 10);


	// Machine ticks in relative clock cycles
	char *cy_start = next;
	char *cy_end;

	SKIP_WHITESPACE(cy_start);
	SEEK_NULL_TERM(cy_end, cy_start);

	(*cy_end) = 0;

	cycles = strtoul(cy_start, NULL, 10);

	free(raw_str);

	// if (param_count > 0)
	// ...

	INDENT(token_scope);
	ADD_TXT("/* REPR:        */  \"%s\",\n", REPR);
	INDENT(token_scope);
	ADD_TXT("/* opcode:      */  0x%02x,\n", opcode);
	INDENT(token_scope);
	ADD_TXT("/* instr_count: */  %d,\n", instr_count);
	INDENT(token_scope);
	ADD_TXT("/* cycles:      */  %d,\n", cycles);


	return;


GROUP_param:		// TODD: implement groupings
GROUP_skip_param:


	INDENT(token_scope);
	ADD_TXT("/* REPR:        */  \"%s\",\n", REPR);


	return;

}

#define PREVIEW_INSTR(_TYPE_, _type_)         \
	INDENT(token_scope);                      \
	ADD_TXT("/** INSTRUCTION " #_type_ "\n"); \
	INDENT(token_scope);                      \
	ADD_TXT("  * %s */\n", yytext);           \
	INDENT(token_scope);                      \
	ADD_TXT("{\n");                           \
	++token_scope;                            \
	tmd[token_scope] = _TYPE_;



void INSTRUCTION_GROUP(char *yytext)
{
	DBG_TRACEL(_INSTRUCTION_GROUP);
	PREVIEW_INSTR(INSTR_GROUPING, gn);

	char *raw_str = malloc(strlen(yytext) + 8); // HACK larger buffer to circumvent segfault
	strcpy(raw_str, yytext);
	PROC_INSTR(raw_str, GROUPING_REGULAR);

	// INDENT(token_scope);
	// ADD_TXT("\"dummy\",\n"); // TODO add final text
}

void INSTRUCTION_GROUP_PARAM(char *yytext)
{
	DBG_TRACEL(_INSTRUCTION_GROUP_PARAM);
	PREVIEW_INSTR(INSTR_GROUPING, gp);

	char *raw_str = malloc(strlen(yytext) + 8); // HACK larger buffer to circumvent segfault
	strcpy(raw_str, yytext);
	PROC_INSTR(raw_str, GROUPING_PARAM);

	// INDENT(token_scope);
	// ADD_TXT("\"dummy\",\n"); // TODO add final text
}

void INSTRUCTION_(char *yytext)
{
	DBG_TRACEL(_INSTRUCTION);
	PREVIEW_INSTR(INSTR, sn);

	char *raw_str = malloc(strlen(yytext) + 8); // HACK larger buffer to circumvent segfault
	strcpy(raw_str, yytext);
	PROC_INSTR(raw_str, SINGLE_REGULAR);

	// INDENT(token_scope);
	// ADD_TXT("\"dummy\",\n"); // TODO add final text
}

void INSTRUCTION_PARAM(char *yytext)
{
	DBG_TRACEL(_INSTRUCTION_PARAM);
	PREVIEW_INSTR(INSTR, sp);

	char *raw_str = malloc(strlen(yytext) + 8); // HACK larger buffer to circumvent segfault
	strcpy(raw_str, yytext);
	PROC_INSTR(raw_str, SINGLE_PARAM);

	// INDENT(token_scope);
	// ADD_TXT("\"dummy\",\n"); // TODO add final text
}
